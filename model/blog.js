// Generated by CoffeeScript 1.10.0
(function() {
  var Blog, Schema, blogSchema, commentSchema, mongoose;

  mongoose = require('mongoose');

  Schema = mongoose.Schema;

  commentSchema = new Schema({
    time: Date,
    content: String,
    user: String,
    userid: String,
    subComments: [
      {
        time: Date,
        content: String,
        user: String,
        userid: String,
        toUser: String
      }
    ]
  });

  blogSchema = new Schema({
    content: String,
    blogHtml: String,
    markdownText: String,
    contentBegin: String,
    tags: [
      {
        tag: String,
        id: Number
      }
    ],
    title: String,
    user: String,
    userid: String,
    date: Date,
    time: {
      year: String,
      month: String,
      day: String,
      minute: String
    },
    imgs: [String],
    isTop: {
      type: Boolean,
      "default": false
    },
    pv: {
      type: Number,
      "default": 0
    },
    editDate: [
      {
        date: Date,
        ip: String
      }
    ],
    comments: [commentSchema]
  });

  blogSchema.statics = {
    returnSelfBlog: function(userid, cb) {
      return this.find({
        userid: userid
      }).sort({
        date: -1
      }).exec(function(err, blogs) {
        if (err) {
          return cb(err, null);
        } else {
          return cb(null, blogs);
        }
      });
    },
    returnAllBlog: function(cb) {
      return this.find().sort({
        isTop: -1,
        date: -1
      }).exec(function(err, blogs) {
        if (err) {
          return cb(err, null);
        } else {
          return cb(null, blogs);
        }
      });
    },
    returnTopBlog: function(cb) {
      return this.find({
        isTop: true
      }).sort({
        isTop: -1,
        date: -1
      }).limit(5).exec(function(err, blogs) {
        if (err) {
          return cb(err, null);
        } else {
          return cb(null, blogs);
        }
      });
    },
    returnPerpageBlogIndex: function(perpage, cb) {
      var blogThis;
      blogThis = this;
      return this.count().exec(function(err, count) {
        if (err) {
          return cb(err, null, 0);
        } else {
          return blogThis.find({}).sort({
            date: -1
          }).limit(perpage).exec(function(err, blogs) {
            if (err) {
              return cb(err, null, 0);
            } else {
              return cb(null, blogs, count);
            }
          });
        }
      });
    },
    returnPerpageBlog: function(perpage, page, cb) {
      var blogThis;
      blogThis = this;
      return this.count().exec(function(err, count) {
        if (err) {
          return cb(err, null, 0);
        } else {
          return blogThis.find({}, null, {
            skip: (page - 1) * perpage,
            limit: perpage
          }).sort({
            date: -1
          }).select('title contentBegin time').exec(function(err, blogs) {
            if (err) {
              return cb(err, null, 0);
            } else {
              return cb(null, blogs, count);
            }
          });
        }
      });
    },
    returnBlogById: function(id, cb) {
      return this.findById(id).exec(function(err, blog) {
        if (err) {
          return cb(err, null);
        } else {
          return cb(null, blog);
        }
      });
    },
    updateBlogPv: function(id) {
      return this.update({
        _id: id
      }, {
        $inc: {
          "pv": 1
        }
      }).exec();
    },
    returnView: function(year, month, cb) {
      var condition, initial, keys, reduce;
      keys = {
        'time.month': true
      };
      condition = null;
      initial = {
        count: 0,
        blogs: []
      };
      reduce = function(doc, aggregator) {
        aggregator.count += 1;
        return aggregator.blogs.push(doc);
      };
      this.collection.group(keys, condition, initial, reduce, null, null, null, function(err, results) {
        var compare, compare2;
        compare = function(value1, value2) {
          return new Date(value2['time.month']) - new Date(value1['time.month']);
        };
        compare2 = function(value1, value2) {
          return value1.date - value2.date;
        };
        results.sort(compare).forEach(function(item, index, arr) {
          return item.blogs.sort(compare2);
        });
        return cb(err, results);
      });
      return {
        readTopAndCount: function(cb) {
          var coverThis;
          coverThis = this;
          return this.count().exec(function(err, count) {
            if (err || count === 0) {
              return cb("err", null, 0);
            } else {
              return coverThis.find({}, null).sort({
                isTop: -1,
                date: -1
              }).limit(1).exec(function(err, covers) {
                if (err) {
                  return cb("err", null, 0);
                } else {
                  return cb(null, covers[0], count);
                }
              });
            }
          });
        }
      };
    }
  };

  Blog = mongoose.model('Blog', blogSchema);

  module.exports = Blog;

}).call(this);
